<nav>
    <ul class="pagination">
        <li class="page-item @PreviousButtonCssClass">
            <a class="page-link" href="javascript:void(0)" @onclick="DecrementPage">Previous</a>
        </li>
        @if (!IsFirstPager)
        {
            <li class="page-item">
                <a class="page-link" href="javascript:void(0)" @onclick="DecrementPager">...</a>
            </li>
        }
        @for (int i = PagerStart; i < PagerEnd; i++)
        {
            int pageIndex = i;
            <li class="page-item @PaginationCssClass(pageIndex)"><a class="page-link" href="javascript:void(0)" @onclick="@(_ => Page(pageIndex))">@(i + 1)</a></li>
        }
        @if (!IsLastPager)
        {
            <li class="page-item">
                <a class="page-link" href="javascript:void(0)" @onclick="IncrementPager">...</a>
            </li>
        }
        <li class="page-item @NextButtonCssClass">
            <a class="page-link" href="javascript:void(0)" @onclick="IncrementPage">Next</a>
        </li>
        <li class="page-item" style="margin-left:5px;">
            @*<Dropdown
                TItem="PageCount"
                Items="PageCounts"
                OnSelect="SelectPageSize"
                ItemName="Page Count"
                ItemNamePlural="Page Counts"
                SelectedItem="PaginationState.PageCount"
                DropUp="true">
                <ItemTemplate Context="pageCount">
                    @pageCount.Display
                </ItemTemplate>
            </Dropdown>*@
        </li>
    </ul>
</nav>



@code {
    private const int PAGE_SIZE = 5, PAGER_COUNT = 5;
    private static readonly int[] pageCountsInts = { 1, 5, 10, 20, 50, 100, 200, 500, 1000, 5000, 10000, 100000 };
    private static readonly PageCount[] pageCounts = pageCountsInts.Select(i => new PageCount(i.ToString(), i)).ToArray();

    private int pageIndex;
    private readonly Pagination pagination = new()
    {
        Take = PAGE_SIZE,
        Skip = 0,
    };

    private string? PreviousButtonCssClass => pageIndex == 0 ? "disabled" : null;
    private string? NextButtonCssClass => IsLastPage ? "disabled" : null;
    private bool IsFirstPager => PagerStart == 0;
    private int PagerStart => pageIndex - (pageIndex % PAGER_COUNT);
    private int PagerCount => TotalPages - PagerStart;
    private bool IsLastPager => PagerCount <= PAGER_COUNT;
    private int PagerEnd => PagerStart + (IsLastPager ? PagerCount : PAGER_COUNT);
    private int TotalPages => (int)Math.Ceiling(ItemCount / (double)pagination.Take);
    private PageCount? PageCount => PageCounts.FirstOrDefault(count => count.Count == pagination.Take);
    private bool IsLastPage => pageIndex == TotalPages - 1;

    [EditorRequired]
    [Parameter]
    public int ItemCount { get; set; } = int.MinValue;

    [EditorRequired]
    [Parameter]
    public EventCallback<Pagination> OnPageCallback { get; set; }

    private string? PaginationCssClass(int pageIndex)
    {
        return pageIndex == this.pageIndex ? "active" : null;
    }

    private async Task SelectPageSize(PageCount pageCount)
    {
        pagination.Take = pageCount.Count;
        if (pageIndex >= TotalPages)
        {
            pageIndex = 0;
            pagination.Skip = 0;
        }

        StateHasChanged();
        await OnPageCallback.InvokeAsync(pagination);
    }

    private IEnumerable<PageCount> PageCounts
    {
        get
        {
            yield return new("All", int.MaxValue);
            bool hasReachedFirstAbove = false;
            for (int i = 0; i < pageCounts.Length; i++)
            {
                if (pageCounts[i].Count >= ItemCount)
                {
                    if (!hasReachedFirstAbove)
                        hasReachedFirstAbove = true;
                    else
                        break;
                }
                yield return pageCounts[i];
            }

        }
    }

    private async Task Page(int pageIndex)
    {
        if (pageIndex >= 0 && pageIndex < TotalPages)
        {
            this.pageIndex = pageIndex;
            pagination.Skip = pageIndex * pagination.Take;
            
            StateHasChanged();
            await OnPageCallback.InvokeAsync(pagination);
        }
    }

    private Task IncrementPage() => Page(pageIndex + 1);

    private Task DecrementPage() => Page(pageIndex - 1);

    private Task IncrementPager() => Page(pageIndex - (pageIndex % PAGER_COUNT) + PAGER_COUNT);

    private Task DecrementPager() => Page(pageIndex - (pageIndex % PAGER_COUNT) - PAGER_COUNT);
}
